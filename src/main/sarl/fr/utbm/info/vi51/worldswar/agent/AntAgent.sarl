package fr.utbm.info.vi51.worldswar.^agent

import fr.utbm.info.vi51.worldswar.^agent.behaviour.strategic.AntStrategicBehaviour
import fr.utbm.info.vi51.worldswar.^agent.^event.AgentInitializedEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.InfluenceEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.KillAgentEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.PerceptionEvent
import fr.utbm.info.vi51.worldswar.environment.influence.Influence
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.util.Scopes
import java.util.HashMap
import java.util.Random
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap

/**
 * Abstract agent inherited by every other ants agents
 */
agent AntAgent {
	uses Lifecycle, Schedules, DefaultContextInteractions, Logging
	
	val memory : HashMap<String, Object> = new HashMap()
	var antInfluences : ConcurrentHashMap<UUID, Influence>
	var behaviour : AntStrategicBehaviour
	var alive : boolean = false
	
	on Initialize{
		synchronized(this) {
			// the strategic behaviour is get from the parameters
			this.behaviour = occurrence.parameters.get(0) as AntStrategicBehaviour
			this.antInfluences = occurrence.parameters.get(1) as ConcurrentHashMap<UUID, Influence>
			this.alive = true
			
			emit(new AgentInitializedEvent)
		}
	}
	
	on KillAgentEvent {
		synchronized(this) {
			// Agent is killed after a random delay.
			// When too many agents are killed at the same time, a memory leak can occur.
			// This is a workaround to prevent this problem.
			this.alive = false
			in(new Random().nextInt(3000)) [killMe]
		}
	}
	
	on PerceptionEvent {
		synchronized(this) {
			val perceptions = occurrence.perceptions
			val nbAgents = occurrence.nbAgents
			val perception = perceptions.get(this.getID)
			if(alive && behaviour !== null ){
				// The influence is computed by the behaviour
				val influence = behaviour.computeInfluence(perception, memory)
				if(influence === null) {
					println("NULL")
				}
				
				if(this.antInfluences.get(this.getID) === null) {
					synchronized(antInfluences) {
						this.antInfluences.put(this.getID, influence)
						if(this.antInfluences.size == nbAgents) {// if all other agents have sent their influence
							
							var evt = new InfluenceEvent()
							emit(evt, 
								Scopes.addresses(occurrence.callbackAddress)
								)
						}
					}
					
				} else {
					println("AntAgent::PerceptionEvent : antInfluence already placed "+ influence+" ||| "+this.antInfluences.get(this.getID))
				}
			} else if (alive) {
				println("AntAgent::PerceptionEvent : ant agent doesn't have a behaviour")
			}
		}
	}
}