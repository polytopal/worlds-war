package fr.utbm.info.vi51.worldswar.^agent

import fr.utbm.info.vi51.worldswar.^agent.behaviour.strategic.AntStrategicBehaviour
import fr.utbm.info.vi51.worldswar.^agent.^event.AgentInitializedEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.InfluenceEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.KillAgentEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.PerceptionEvent
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.util.Scopes
import java.util.HashMap
import java.util.Random

/**
 * Abstract agent inherited by every other ants agents
 */
agent AntAgent {
	uses Lifecycle, Schedules, DefaultContextInteractions, Logging
	
	val memory : HashMap<String, Object> = new HashMap()
	var behaviour : AntStrategicBehaviour
	
	on Initialize{
		synchronized(this) {
			// the strategic behaviour is get from the parameters
			this.behaviour = occurrence.parameters.get(0) as AntStrategicBehaviour
			
			emit(new AgentInitializedEvent)
		}
	}
	
	on KillAgentEvent {
		synchronized(this) {
			// Agent is killed after a random delay.
			// When too many agents are killed at the same time, a memory leak can occur.
			// This is a workaround to prevent this problem.
			in(new Random().nextInt(3000)) [killMe]
		}
	}
	
	on PerceptionEvent {
		synchronized(this) {
			
			val perception = occurrence.perception
			if(behaviour !== null ){
				
				// The influence is computed by the behaviour
				val influence = behaviour.computeInfluence(perception, memory)
				emit(new InfluenceEvent(this.getID(), influence),
					Scopes.addresses(occurrence.callbackAddress))
			}else{
				error("ant agent doesn't have behaviour")
			}
			
		}
	}
}