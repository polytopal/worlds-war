package fr.utbm.info.vi51.worldswar.environment

import fr.utbm.info.vi51.worldswar.^agent.AntAgent
import fr.utbm.info.vi51.worldswar.^agent.GathererAgent
import fr.utbm.info.vi51.worldswar.^agent.^event.AgentInitializedEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.InfluenceEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.KillAgentEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.PerceptionEvent
import fr.utbm.info.vi51.worldswar.controller.SimulationParameters
import fr.utbm.info.vi51.worldswar.environment.envobject.AgentBody
import fr.utbm.info.vi51.worldswar.environment.envobject.AntBody
import fr.utbm.info.vi51.worldswar.simulator.SimulationStepEvent
import fr.utbm.info.vi51.worldswar.simulator.StopSimulationEvent
import fr.utbm.info.vi51.worldswar.utils.Grid
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.util.Scopes
import java.awt.Point
import java.util.HashMap
import java.util.LinkedList
import java.util.List
import java.util.UUID
import fr.utbm.info.vi51.worldswar.simulator.SimulatorListener

/**
 * While it does not appear obvious, this agent manages the environment.
 * */
agent Environment {
	uses Logging, DefaultContextInteractions, Lifecycle
	
	val AGENTS_MAP_INITIAL_SIZE : int = 1000
	
	//TODO to remove
//	var width : int
//	var height : int
	// X min = Y min = 0
	// X max = width-1
	// Y max = height-1
	
	private var listeners : List<SimulatorListener>
	
	var grid : Grid<EnvCell>
	var agentBodies : HashMap<UUID, AgentBody>
	var influencesReceived : int

	/** List of the UUID of agents that have been spawned, but are not initialized yet */
	var uninitializedAgents : List<UUID>
	/** True if and only if the environment is waiting one or more agents to finish their initialization before finishing its step. */
	var waitingAgentsInitialization : boolean

	on Initialize {
		synchronized(this) {
			var simParameters = occurrence.parameters.get(0) as SimulationParameters
			this.listeners = occurrence.parameters.get(1) as List<SimulatorListener>
			
//			this.width = simParameters.gridWidth
//			this.height = simParameters.gridHeight
			
			this.grid = EnvironmentUtils.generateGround(simParameters)
			
			
			info("Creating agents map...")
			this.agentBodies = new HashMap(AGENTS_MAP_INITIAL_SIZE)
			info("Map created")
			
			this.uninitializedAgents = new LinkedList
			this.waitingAgentsInitialization = false
			
			//TODO for testing purpose, should be removed when we have ants spawners
//			for(var i=0; i<500; i++) {
//				spawnAnt(new Colony(Breed.DARK_ANTS), Caste.GATHERER, new Point(0,0))
//			}
//			info("Ants spawned")
			
			emit(new EnvironmentInitializedEvent)
		}
	}
	
	on StopSimulationEvent {
		synchronized(this) {
			info("Environment stopping")
			emit(new KillAgentEvent)
			killMe
		}
	}
	
	on Destroy {
		synchronized(this) {
			emit(new EnvironmentTerminatedEvent)
		}
	}
	
	on SimulationStepEvent {
		synchronized(this) {
			var perceptionGrid = PerceptionGrid.buildFromEnvObjectGrid(grid)

//			info("perceptionGrid computed :")
//			info(perceptionGrid)

			for(l : this.listeners) {
				l.environmentUpdated(perceptionGrid)
			}
			
			influencesReceived = 0
			sendPerceptionsToAgents(perceptionGrid)
		}
	}
	
	/**
	 * Invoked when all influences have been received.
	 * Performs the changes to the envObjects for this step.
	 * Once this is done, the environment is ready for a new step.
	 */
	
	private def applyStep {
		applyInfluences
		
		EnvironmentUtils.applyPheromoneDissipation(grid)
		//TODO apply other world rules, ants spawns and ants dying of old age
		
		
		if(this.uninitializedAgents.size > 0) {
			this.waitingAgentsInitialization = true
		}
		else {
			finishStep
		}
	}
	
	/**
	 * Invoked when all the computation for the current step is done. This will tell the environment is ready to compute a new one.
	 */
	private def finishStep {
		this.waitingAgentsInitialization = false
		emit(new EnvironmentReadyEvent)
	}
	
	/**
	 * Applies the ant influence stored in their bodies, then clear them.
	 */
	private def applyInfluences {
		
		//TODO implement
		
		
		// Clear all the stored influences because we don't want them anymore
		for(body : agentBodies.values()) {
			body.influence = null
		}
	}
	
	/**
	 * Receive an influence : store it in the proper agentBody and increase the count of influences received for the current step
	 */
	on InfluenceEvent {
		synchronized(this) {
			var body = agentBodies.get(occurrence.uuid);
			
			if(body.influence !== null) {
				error("Agent #" + occurrence.uuid + " has sent multiple influences in the same step")
			}
			else {
				body.influence = occurrence.influence
				influencesReceived++
				
				if(influencesReceived == agentBodies.size) {
					applyStep
				}
			}
		}
	}
	
	
	////////////////////////////////////////
	///         SPAWN/KILL AGENTS        ///
	////////////////////////////////////////
	
	private def spawnAnt(colony : Colony, caste : Caste, position : Point) {
		
		//TODO determine the class depending on the caste of the ant to spawn
		var agentClass : Class<? extends AntAgent> = typeof(GathererAgent)
		
		var antUuid : UUID = spawn(agentClass)
		var body : AntBody = new AntBody(position, antUuid, colony, caste)
		
		//Add the new body in the proper cell of the grid, and in the agentBodies table
		this.grid.get(position).addEnvObject(body)
		this.agentBodies.put(antUuid, body)
		this.uninitializedAgents.add(antUuid)
	}
	
	private def killAgent(uuid : UUID) {
		var body = agentBodies.get(uuid)
		
		if(!this.grid.get(body.position).removeEnvObject(body)) {
			error("Body not found in grid when killing agent #" + uuid)
		}
		if(this.agentBodies.remove(uuid) === null) {
			error("Body not found in hashmap when killing agent #" + uuid)
		}
		// This is unlikely to happen, but an agent can theoretically be "spawn killed", killed in the same step is was spawned, 
		// hence potentially killed before its initialization was complete.
		if(this.uninitializedAgents.remove(uuid)) {
			warning("Agent #" + uuid + " was killed before it was fully initialized")
		}
		
		emit(new KillAgentEvent, Scopes.addresses(defaultSpace.getAddress(body.uuid)))
	}
	
	on AgentInitializedEvent {
		synchronized(this) {
			var agentUUID = occurrence.source.UUID
			if(!uninitializedAgents.remove(agentUUID)) {
				error("Agent #" + agentUUID + "said he was just initialized, but we didn't expect him to initialize now")
			}
			//If this is the last agent we were waiting for, we finish the step.
			if(this.waitingAgentsInitialization && this.uninitializedAgents.isEmpty) {
				finishStep
			}
		}
	}
	
	////////////////////////////////////////
	///            PERCEPTIONS           ///
	////////////////////////////////////////
	
	
	def sendPerceptionsToAgents(perceptionGrid : PerceptionGrid) {
		
		//If there is no agent, there is no perception to send, and no influence to wait.
		//We can directly apply the step
		if(agentBodies.isEmpty) {
			applyStep
			return
		}
		
		for(agentBody : agentBodies.values()) {
			
			val agentPerception = perceptionGrid.computeAgentPerception(agentBody)
			
			emit(new PerceptionEvent(this.defaultAddress, agentPerception), Scopes.addresses(defaultSpace.getAddress(agentBody.uuid))
			)
		}
	}
	
}