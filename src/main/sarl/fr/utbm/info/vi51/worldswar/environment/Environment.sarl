package fr.utbm.info.vi51.worldswar.environment

import fr.utbm.info.vi51.worldswar.^agent.AntAgent
import fr.utbm.info.vi51.worldswar.^agent.BehaviourHandler
import fr.utbm.info.vi51.worldswar.^agent.^event.AgentInitializedEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.InfluenceEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.KillAgentEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.PerceptionEvent
import fr.utbm.info.vi51.worldswar.controller.SimulationParameters
import fr.utbm.info.vi51.worldswar.environment.envobject.AgentBody
import fr.utbm.info.vi51.worldswar.environment.envobject.AntBody
import fr.utbm.info.vi51.worldswar.environment.envobject.AntHill
import fr.utbm.info.vi51.worldswar.environment.influence.BurrowInfluence
import fr.utbm.info.vi51.worldswar.environment.influence.DropFoodInfluence
import fr.utbm.info.vi51.worldswar.environment.influence.MeleeAttackInfluence
import fr.utbm.info.vi51.worldswar.environment.influence.MoveInfluence
import fr.utbm.info.vi51.worldswar.environment.influence.PheromoneAndMoveInfluence
import fr.utbm.info.vi51.worldswar.environment.influence.PickFoodInfluence
import fr.utbm.info.vi51.worldswar.simulator.SimulationStepEvent
import fr.utbm.info.vi51.worldswar.simulator.SimulatorListener
import fr.utbm.info.vi51.worldswar.simulator.StopSimulationEvent
import fr.utbm.info.vi51.worldswar.utils.Grid
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.util.Scopes
import java.awt.Point
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.LinkedList
import java.util.List
import java.util.UUID

/**
 * While it does not appear obvious, this agent manages the environment.
 * */
agent Environment {
	uses Logging, DefaultContextInteractions, Lifecycle
	
	val AGENTS_MAP_INITIAL_SIZE : int = 1000
	
	private var listeners : List<SimulatorListener>
	
	/** an object that create the behaviours */
	var behaviourHandler : BehaviourHandler
	
	var grid : Grid<EnvCell>
	var antHills : List<AntHill>

	var agentBodies : HashMap<UUID, AgentBody>
	var influencesReceived : int

	/** List of the UUID of agents that have been spawned, but are not initialized yet */
	var uninitializedAgents : List<UUID>
	/** True if and only if the environment is waiting one or more agents to finish their initialization before finishing its step. */
	var waitingAgentsInitialization : boolean
	
	

	on Initialize {
		synchronized(this) {
			var simParameters = occurrence.parameters.get(0) as SimulationParameters
			this.listeners = occurrence.parameters.get(1) as List<SimulatorListener>
			
			this.behaviourHandler = new BehaviourHandler
			
			this.grid = EnvironmentUtils.generateMap(simParameters)
			
			
			this.antHills = new ArrayList
			
			// ------ test -----
//			var point = new Point(3, 3)
//			var hill = new AntHill(point,new Colony(Breed.DARK_ANTS))
//			grid.get(point).addEnvObject(hill)
//			this.antHills.add(hill)
			// -----------------
			
			info("Creating agents map...")
			this.agentBodies = new HashMap(AGENTS_MAP_INITIAL_SIZE)
			info("Map created")
			
			this.uninitializedAgents = new LinkedList
			this.waitingAgentsInitialization = false
			
			
			
			
			emit(new EnvironmentInitializedEvent)
		}
	}
	
	on StopSimulationEvent {
		synchronized(this) {
			info("Environment stopping")
			emit(new KillAgentEvent)
			killMe
		}
	}
	
	on Destroy {
		synchronized(this) {
			emit(new EnvironmentTerminatedEvent)
		}
	}
	
	on SimulationStepEvent {
		synchronized(this) {
			var perceptionGrid = PerceptionGrid.buildFromEnvObjectGrid(grid)

			for(l : this.listeners) {
				l.environmentUpdated(perceptionGrid)
			}
			
			influencesReceived = 0
			sendPerceptionsToAgents(perceptionGrid)
		}
	}
	
	/**
	 * Invoked when all influences have been received.
	 * Performs the changes to the envObjects for this step.
	 * Once this is done, the environment is ready for a new step.
	 */
	
	private def applyStep {
		applyInfluences
		
		EnvironmentUtils.applyPheromoneDissipation(grid)
		antsAging
		spawnAntsInAntHills
		if(this.uninitializedAgents.size > 0) {
			this.waitingAgentsInitialization = true
		}
		else {
			finishStep
		}
	}
	
	/**
	 * Invoked when all the computation for the current step is done. This will tell the environment is ready to compute a new one.
	 */
	private def finishStep {
		this.waitingAgentsInitialization = false
		emit(new EnvironmentReadyEvent)
	}
	
	/**
	 * Applies the ant influence stored in their bodies, then clear them.
	 */
	private def applyInfluences {
		
		var shuffledUuids = new LinkedList(agentBodies.keySet)
		Collections.shuffle(shuffledUuids)
		for(uuid : shuffledUuids) {
			// Currently, all of our agents are ants, so our influences apply to ants. 
			// If we add other types of agents, the nature of the agent and the influences he can send will have to be determined.
			val antBody = agentBodies.get(uuid) as AntBody
			if(antBody !== null) {
				applyAntInfluence(antBody)
				antBody.influence = null
			}
		}
	}
	
	private def applyAntInfluence(ant : AntBody) {
		val influence = ant.influence
		
		if(influence instanceof BurrowInfluence) {
			EnvironmentUtils.burrow(ant, grid)
		} else if(influence instanceof DropFoodInfluence) {
			EnvironmentUtils.dropFood(ant, influence.droppedAmount, grid)
		} else if(influence instanceof MeleeAttackInfluence) {
			throw(new UnsupportedOperationException("No fights only farm pls"))
		} else if(influence instanceof MoveInfluence) {
			EnvironmentUtils.moveAnt(ant, influence.direction, grid)
		} else if (influence instanceof PheromoneAndMoveInfluence) {
			EnvironmentUtils.placePheromone(ant.colony, influence.pheromoneType, influence.pheromoneQty, ant.position, grid)
			EnvironmentUtils.moveAnt(ant, influence.direction, grid)
		} else if (influence instanceof PickFoodInfluence) {
			EnvironmentUtils.pickFood(ant, influence.qty, grid)
		}
	}
	
	/**
	 * Receive an influence : store it in the proper agentBody and increase the count of influences received for the current step
	 */
	on InfluenceEvent {
		synchronized(this) {
			var body = agentBodies.get(occurrence.uuid);
			
			if(body.influence !== null) {
				error("Agent #" + occurrence.uuid + " has sent multiple influences in the same step")
			}
			else {
				body.influence = occurrence.influence
				influencesReceived++
				
				if(influencesReceived == agentBodies.size) {
					applyStep
				}
			}
		}
	}
	
	
	////////////////////////////////////////
	///         SPAWN/KILL AGENTS        ///
	////////////////////////////////////////
	
	private def spawnAnt(colony : Colony, caste : Caste, position : Point) {
		
		// the ant behaviour is passed as a parameters
		var antUuid : UUID = spawn(typeof(AntAgent), behaviourHandler.getStrategicBehaviour(caste))
		var body : AntBody = new AntBody(position, antUuid, colony, caste)
		
		//Add the new body in the proper cell of the grid, and in the agentBodies table
		this.grid.get(position).addEnvObject(body)
		this.agentBodies.put(antUuid, body)
		this.uninitializedAgents.add(antUuid)
	}
	
	private def killAgent(uuid : UUID) {
		var body = agentBodies.get(uuid)
		
		if(!this.grid.get(body.position).removeEnvObject(body)) {
			error("Body not found in grid when killing agent #" + uuid)
		}
		if(this.agentBodies.remove(uuid) === null) {
			error("Body not found in hashmap when killing agent #" + uuid)
		}
		// This is unlikely to happen, but an agent can theoretically be "spawn killed", killed in the same step is was spawned, 
		// hence potentially killed before its initialization was complete.
		if(this.uninitializedAgents.remove(uuid)) {
			warning("Agent #" + uuid + " was killed before it was fully initialized")
		}
		
		emit(new KillAgentEvent, Scopes.addresses(defaultSpace.getAddress(body.uuid)))
	}
	
	on AgentInitializedEvent {
		synchronized(this) {
			var agentUUID = occurrence.source.UUID
			if(!uninitializedAgents.remove(agentUUID)) {
				error("Agent #" + agentUUID + "said he was just initialized, but we didn't expect him to initialize now")
			}
			//If this is the last agent we were waiting for, we finish the step.
			if(this.waitingAgentsInitialization && this.uninitializedAgents.isEmpty) {
				finishStep
			}
		}
	}
	
	////////////////////////////////////////
	///            PERCEPTIONS           ///
	////////////////////////////////////////
	
	
	def sendPerceptionsToAgents(perceptionGrid : PerceptionGrid) {
		
		//If there is no agent, there is no perception to send, and no influence to wait.
		//We can directly apply the step
		if(agentBodies.isEmpty) {
			applyStep
			return
		}
		
		for(agentBody : agentBodies.values()) {
			
			val agentPerception = perceptionGrid.computeAgentPerception(agentBody)
			
			emit(new PerceptionEvent(this.defaultAddress, agentPerception), Scopes.addresses(defaultSpace.getAddress(agentBody.uuid))
			)
		}
	}
	
	
	////////////////////////////////////////
	///            WORLD RULES           ///
	////////////////////////////////////////
	
	/** To be called each step. Periodically spawn an ant inside each anthill */
	private def spawnAntsInAntHills {
		for(antHill : this.antHills) {
			antHill.decrementSpawnCooldown
			if(antHill.spawnCooldown === 0 && antHill.availableFood >= AntHill.SPAWN_COST) {
				antHill.pickFood(AntHill.SPAWN_COST)
				antHill.spawnCooldown = AntHill.SPAWN_COOLDOWN
				//TODO spawn some other castes sometimes
				this.spawnAnt(antHill.colony, Caste.GATHERER, antHill.position)
				
			}
		}
	}

	/** Simulates ants aging, kill agents that are too old */
	private def antsAging {
		var toKill = new LinkedList<UUID>
		for(body : this.agentBodies.values) {
			if(body instanceof AntBody) {
				body.decrementRemainingLifeTime
				if(body.remainingLifeTime < 0) {
					toKill += body.uuid
				}
			}
		}
		for(uuid : toKill) {
			this.killAgent(uuid)
		}
	}
}