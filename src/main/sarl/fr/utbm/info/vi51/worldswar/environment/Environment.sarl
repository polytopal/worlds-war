package fr.utbm.info.vi51.worldswar.environment

import fr.utbm.info.vi51.worldswar.^agent.AntAgent
import fr.utbm.info.vi51.worldswar.^agent.GathererAgent
import fr.utbm.info.vi51.worldswar.^agent.^event.DeadAgentEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.InfluenceEvent
import fr.utbm.info.vi51.worldswar.^agent.^event.PerceptionEvent
import fr.utbm.info.vi51.worldswar.environment.envobject.AgentBody
import fr.utbm.info.vi51.worldswar.environment.envobject.AntBody
import fr.utbm.info.vi51.worldswar.environment.envobject.AntHill
import fr.utbm.info.vi51.worldswar.environment.envobject.Food
import fr.utbm.info.vi51.worldswar.environment.envobject.Pheromone
import fr.utbm.info.vi51.worldswar.environment.envobject.Wall
import fr.utbm.info.vi51.worldswar.environment.perceivable.Perceivable
import fr.utbm.info.vi51.worldswar.environment.perceivable.PerceivableAnt
import fr.utbm.info.vi51.worldswar.environment.perceivable.PerceivableAntHill
import fr.utbm.info.vi51.worldswar.environment.perceivable.PerceivableFood
import fr.utbm.info.vi51.worldswar.environment.perceivable.PerceivablePheromone
import fr.utbm.info.vi51.worldswar.environment.perceivable.PerceivableWall
import fr.utbm.info.vi51.worldswar.simulator.SimulationStepEvent
import fr.utbm.info.vi51.worldswar.simulator.StopSimulationEvent
import fr.utbm.info.vi51.worldswar.utils.Grid
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.util.Scopes
import java.awt.Point
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.UUID
import fr.utbm.info.vi51.worldswar.controller.SimulationParameters

/**
 * While it does not appear obvious, this agent manages the environment.
 * */
agent Environment {
	uses Logging, DefaultContextInteractions, Lifecycle
	
	val AGENTS_MAP_INITIAL_SIZE : int = 1000
	
	var width : int
	var height : int
	// X min = Y min = 0
	// X max = width-1
	// Y max = height-1
	
	var grid : Grid<Cell>
	var agentBodies : HashMap<UUID, AgentBody>
	var influencesReceived : int

	on Initialize {
		
		var simParameters = occurrence.parameters.get(0) as SimulationParameters
		this.width = simParameters.gridWidth
		this.height = simParameters.gridHeight
		
		this.grid = new Grid(0, this.width-1, 0, this.height-1)
		for(var x = 0; x < this.width; x++) {
			for(var y = 0; y < this.height; y++) {
				this.grid.set(x,y, new Cell)
			}
		}
		
		info("Creating map...")
		this.agentBodies = new HashMap(AGENTS_MAP_INITIAL_SIZE)
		info("Map created")
		
		
		//TODO map generation, also store the colonies of the simParameters somewhere safe
		
		//TODO for testing purpose, should be removed when we have ants spawners
//		for(var i=0; i<500; i++) {
//			spawnAnt(new Colony(Breed.DARK_ANTS), Caste.GATHERER, new Point(0,0))
//		}
//		info("Ants spawned")
		
		emit(new EnvironmentInitializedEvent) 
	}
	
	
	on StopSimulationEvent {
		killMe
	}
	
	on Destroy {
		emit(new EnvironmentTerminatedEvent)
	}
	
	on SimulationStepEvent {
		
		var perceptionGrid = computePerceptionGrid
		
		// TODO - send the complete grid to the listeners (the gui)
		
		influencesReceived = 0
		sendPerceptionsToAgents
	}
	
	/**
	 * Invoked when all influences have been received.
	 * Performs the changes to the envObjects for this step.
	 * Once this is done, the environment is ready for a new step.
	 */
	
	private def applyStep {
		applyInfluences
		
		EnvironmentUtils.applyPheromoneDissipation(grid)
		//TODO apply other world rules, ants spawns and ants dying of old age
		
		emit(new EnvironmentReadyEvent)
	}
	
	/**
	 * Applies the ant influence stored in their bodies, then clear them.
	 */
	private def applyInfluences {
		
		//TODO implement
		
		
		// Clear all the stored influences because we don't want them anymore
		for(body : agentBodies.values()) {
			body.influence = null
		}
	}
	
	/**
	 * Receive an influence : store it in the proper agentBody and increase the count of influences received for the current step
	 */
	on InfluenceEvent {
		var body = agentBodies.get(occurrence.uuid);
		
		if(body.influence !== null) {
			error("Agent #" + occurrence.uuid + " has sent multiple influences in the same step")
		}
		else {
			body.influence = occurrence.influence
			influencesReceived++
			
			if(influencesReceived == agentBodies.size) {
				applyStep
			}
		}
	}
	
	
	////////////////////////////////////////
	///         SPAWN/KILL AGENTS        ///
	////////////////////////////////////////
	
	private def spawnAnt(colony : Colony, caste : Caste, position : Point) {
		
		//TODO determine the class depending on the caste of the ant to spawn
		var agentClass : Class<? extends AntAgent> = typeof(GathererAgent)
		
		var antUuid : UUID = spawn(agentClass)
		var body : AntBody = new AntBody(position, antUuid, colony, caste)
		
		//Add the new body in the proper cell of the grid, and in the agentBodies table
		this.grid.get(position).addEnvObject(body)
		this.agentBodies.put(antUuid, body)
	}
	
	private def killAgent(uuid : UUID) {
		var body = agentBodies.get(uuid)
		
		if(!this.grid.get(body.position).removeEnvObject(body)) {
			error("Body not found in grid when killing agent #" + uuid)
		}
		if(this.agentBodies.remove(uuid) === null) {
			error("Body not found in hashmap when killing agent #" + uuid)
		}
		emit(new DeadAgentEvent, Scopes.addresses(defaultSpace.getAddress(body.uuid)))
	}
	
	
	////////////////////////////////////////
	///            PERCEPTIONS           ///
	////////////////////////////////////////
	
	def computePerceptionGrid : Grid<List<Perceivable>>{
		var perceptionGrid = new Grid<List<Perceivable>>(0, width-1, 0, height-1)
		
		for(var x = 0; x < width; x++) {
			for(var y = 0; y < height; y++) {
				// foreach cell
				
				var perceptionList : List<Perceivable> = new ArrayList<Perceivable>
				perceptionGrid.set(x,y, perceptionList)
				
				var envObjectList = grid.get(x, y).getEnvObjects
				
				// foreach Environment object in the cell
				for(envObj : envObjectList){
					var perceivable : Perceivable
					
					// we change each envObject in Perceivable
					if(envObj instanceof AntBody){
						perceivable = new PerceivableAnt(envObj)
					}else if(envObj instanceof AntHill){
						perceivable = new PerceivableAntHill(envObj)
					}else if(envObj instanceof Food){
						perceivable = new PerceivableFood(envObj)
					}else if(envObj instanceof Pheromone){
						perceivable = new PerceivablePheromone(envObj)
					}else if(envObj instanceof Wall){
						perceivable = new PerceivableWall(envObj)
					}
					
					if(perceivable !== null){
						perceptionList.add(perceivable)
					}
				}
				
			}
		}
	
		return perceptionGrid;
	}
	
	private def sendPerceptionsToAgents {
		
		//If there is no agent, there is no perception to send, and no influence to wait.
		//We can directly apply the step
		if(agentBodies.isEmpty) {
			applyStep
			return
		}
		
		for(agentBody : agentBodies.values()) {
			emit(new PerceptionEvent(this.defaultAddress), 
				Scopes.addresses(defaultSpace.getAddress(agentBody.uuid))
			)
		}
	}
}