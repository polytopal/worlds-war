package fr.utbm.info.vi51.worldswar.simulator

import fr.utbm.info.vi51.worldswar.controller.Controller
import fr.utbm.info.vi51.worldswar.controller.ControllerCommandEvent
import fr.utbm.info.vi51.worldswar.controller.commands.SimulationSpeedCommand
import fr.utbm.info.vi51.worldswar.environment.Environment
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.util.List
import java.util.LinkedList
import fr.utbm.info.vi51.worldswar.environment.EnvironmentReadyEvent
import fr.utbm.info.vi51.worldswar.gui.Window
import fr.utbm.info.vi51.worldswar.controller.NewSimulationCommand
import fr.utbm.info.vi51.worldswar.controller.StopSimulationCommand
import fr.utbm.info.vi51.worldswar.environment.EnvironmentTerminatedEvent

/**
 * Main agent of the software.
 * Manages the flow of the simulation
 */
agent Simulator {
	uses Logging, Schedules, DefaultContextInteractions
	
	/** Delay in ms, when a new environment is generated, before the simulation begins */
	private final val STARTUP_DELAY = 2000
	
	private var controller : Controller
	private var gui : Window
	
	private var listeners : List<SimulatorListener>

	/** Simulation speed, as chosen by the user */
	private var simulationSpeed = SimulationSpeed.NORMAL
	
	/** Indicates whether the step timer has passed, hence a new step should be fired */
	private var stepToFire = false
	/** Indicates whether the environment is ready to compute a new step */
	private var environmentReady = false
	/** Indicates if the simulation is currently running */
	private var simulationRunning = false
	/** Indicates if the simulation is currently stopping */
	
	private var newSimulationPending = false
	
	on Initialize {
		controller = new Controller(defaultSpace)
		gui = new Window(controller)
		
		listeners = new LinkedList
		listeners.add(gui)
		
	}
	
	private def newSimulation {
		if(simulationRunning) {
			stopSimulation
			newSimulationPending = true
		} else {
			simulationRunning = true
			newSimulationPending = false
			spawn(typeof(Environment))
			environmentReady = true
			stepToFire = true
			fireSimulationStep
		}
		
	}
	
	private def stopSimulation {
		environmentReady = false
		stepToFire = false
		emit(new StopSimulationEvent)
	}
	on EnvironmentReadyEvent {
		environmentReady = true
		fireSimulationStep
	}
	
	private def stepReady {
		stepToFire = true
		fireSimulationStep
	}
	
	/** Checks that both the step timer and the environment allow a new step to be fired, 
	 * and fire this new step if that's the case.
	 */
	private def fireSimulationStep {
		if(stepToFire && environmentReady && simulationRunning) {
			environmentReady = false
			stepToFire = false
			emit(new SimulationStepEvent)
			for(l as SimulatorListener : listeners) {
				l.simulationStepFired
			}
			in(simulationSpeed.milliseconds) [ stepReady ]
		} else if (!simulationRunning) {
			if (newSimulationPending) {
				newSimulation
			}
		}
	}
	
	/**
	 * Handles the controller's commands
	 */
	on ControllerCommandEvent {
		if(occurrence.command instanceof SimulationSpeedCommand) {
			var command = occurrence.command as SimulationSpeedCommand
			this.simulationSpeed = command.speed
		} else if (occurrence.command instanceof NewSimulationCommand) {
			newSimulation
		} else if (occurrence.command instanceof StopSimulationCommand) {
			stopSimulation
		}
	}
	
	on EnvironmentTerminatedEvent {
		simulationRunning = false
	}
}