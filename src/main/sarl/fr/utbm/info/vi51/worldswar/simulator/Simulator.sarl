package fr.utbm.info.vi51.worldswar.simulator

import fr.utbm.info.vi51.worldswar.controller.Controller
import fr.utbm.info.vi51.worldswar.controller.ControllerCommandEvent
import fr.utbm.info.vi51.worldswar.controller.NewSimulationCommand
import fr.utbm.info.vi51.worldswar.controller.SimulationSpeedCommand
import fr.utbm.info.vi51.worldswar.controller.StopProgramCommand
import fr.utbm.info.vi51.worldswar.controller.StopSimulationCommand
import fr.utbm.info.vi51.worldswar.environment.Environment
import fr.utbm.info.vi51.worldswar.environment.EnvironmentReadyEvent
import fr.utbm.info.vi51.worldswar.environment.EnvironmentTerminatedEvent
import fr.utbm.info.vi51.worldswar.gui.Window
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
import java.util.LinkedList
import java.util.List

/**
 * Main agent of the software.
 * Manages the flow of the simulation
 */
agent Simulator {
	uses Schedules, DefaultContextInteractions, Lifecycle
	
	/** Delay in ms, when a new environment is generated, before the simulation begins */
	private final val STARTUP_DELAY = 2000
	
	/** the controller is what allows the simulator to receive events from the gui */
	private var controller : Controller
	private var gui : Window
	
	/** list of listeners of the Simulator, which will receive events from the Simulator */
	private var listeners : List<SimulatorListener>

	/** Simulation speed, as chosen by the user */
	private var simulationSpeed = SimulationSpeed.getDefaultSpeed
	
	/** Indicates whether the step timer has passed, hence a new step should be fired */
	private var stepToFire = false
	/** Indicates whether the environment is ready to compute a new step */
	private var environmentReady = false
	/** Indicates if the simulation is currently running */
	private var simulationRunning = false
	/** Indicates if a new simulation is pending */
	private var newSimulationPending = false
	/** Indicates if the simulator should kill himself when the environment terminates */
	private var stopProgramPending = false
	
	on Initialize {
		controller = new Controller(defaultSpace)
		gui = new Window(controller)
		
		listeners = new LinkedList
		listeners.add(gui)
		
	}
	
	/** this method is used to start a new simulation.
	 * If a simulation is currently running, it stops 
	 * the current one and sets the newSimulationPending flag,
	 * which will cause newSimulation to be called once the 
	 * simulation is stopped
	 */
	private def newSimulation{
		
		
		if(simulationRunning) {
			stopSimulation
			newSimulationPending = true
		} else {
			simulationRunning = true
			newSimulationPending = false
			spawn(typeof(Environment))
			environmentReady = false
			stepToFire = true
			
			for(l as SimulatorListener : listeners) {
				l.simulationStarted
			}
		}
		
	}
	
	/** When the GUI sends a StopSimulationCommand,
	 *  this method is called, stops the next simulationStep,
	 * 	and sends a StopSimulationEvent, signaling the
	 *  environment and the agents to terminate.
	 */ 
	private def stopSimulation {
		environmentReady = false
		stepToFire = false
		emit(new StopSimulationEvent)
	}
	on EnvironmentReadyEvent {
		environmentReady = true
		fireSimulationStep
	}
	
	private def stepReady {
		stepToFire = true
		fireSimulationStep
	}
	
	/** Checks that both the step timer and the environment allow a new step to be fired, 
	 * and fire this new step if that's the case. Also verify that the simulation is
	 * currently running(the environment being terminated resulting in simulationRunning = false)
	 * if the simulation isn't running and there is a pending simulation, start it
	 */
	private def fireSimulationStep {
		if(stepToFire && environmentReady && simulationRunning) {
			environmentReady = false
			stepToFire = false
			emit(new SimulationStepEvent)
			for(l as SimulatorListener : listeners) {
				l.simulationStepFired
			}
			in(simulationSpeed.milliseconds) [ stepReady ]
		} else if (!simulationRunning) {
			if (newSimulationPending) {
				newSimulation
			}
		}
	}
	
	/**
	 * Handles the controller's commands
	 */
	on ControllerCommandEvent {
		if(occurrence.command instanceof SimulationSpeedCommand) {
			var command = occurrence.command as SimulationSpeedCommand
			this.simulationSpeed = command.speed
		} else if (occurrence.command instanceof NewSimulationCommand) {
			var command = occurrence.command as NewSimulationCommand
			//TODO do something with "simulationParameters"
			var simulationParameters = command.getSimulationParameters
			
			newSimulation
		} else if (occurrence.command instanceof StopSimulationCommand) {
			stopSimulation
		} else if (occurrence.command instanceof StopProgramCommand) {
			stopProgramPending = true
			stopSimulation
		}
	}
	
	/**
	 * When the environment is terminated, the simulationRunning flag is set to false
	 * in order to stop the simulationStep loop. the listeners of the simulator are also
	 * signaled, in particular so that the GUI is aware of the state of the simulation.
	 */
	on EnvironmentTerminatedEvent {
		if (stopProgramPending) {
			killMe()
		} else {
			simulationRunning = false
			for(l as SimulatorListener : listeners) {
					l.simulationTerminated
			}
		}
		
	}
}